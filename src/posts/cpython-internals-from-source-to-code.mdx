---
title: "CPython Internals: Execution Process"
date: "2020-10-11"
coverImage: "../images/neutral.jpg"
path: "/liskov-substitution-principle-in-functional-typescript"
excerpt: "If it looks like a duck, quacks like a duck, but needs batteries, you probably have the wrong abstraction."
tags: []
---
import { ReactComponent as PythonExecutionSteps } from "../images/python-execution-steps.svg";


_This is part three of a five-part series about SOLID principles in functional TypeScript._

## What is CPython?

Python is a language. A programming language is a notation for writing programs, which are specifications of a computation or algorithm.
This means that it's simply the rules and syntax for writing code. Separately we have a programming language implementation.

The standard language implementation of Python is CPython.
CPython can be defined as both an interpreter and a compiler as it compiles Python code into bytecode before interpreting it.

## Execution Process
CPython compiles your Python source code into bytecode. That bytecode is then executed on the CPython Virtual Machine.
<PythonExecutionSteps className="excalidraw" />

Now, `Shape` is substitutable by both `Rectangle` and `Square`, because none of the two subtypes break the behavior defined by `Shape`.

As you might have noticed, steering clear from inheritance is one way to avoid LSP violations.
Which is yet another example of composition over inheritance.

## In conclusion

The LSP goes a quack further from the [open-closed principle](/open-closed-principle-in-functional-typescript) because not only should we prefer extending modules over modifying them, we should avoid modifying existing behaviors from said extensions; only build over it.

## Sources
- [How CPython's Compiler Works - Brett Cannon](https://www.youtube.com/watch?v=R31NRWgoIWM)
- [Open-Closed Principle](/open-closed-principle-in-functional-typescript)
