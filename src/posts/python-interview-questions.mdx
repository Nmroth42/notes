---
title: "Python interview questions"
date: "2020-10-11"
coverImage: "../images/doge2.jpg"
path: "/python-interview-questions"
excerpt: ""
tags: []
---
import { ReactComponent as PythonPyobject } from "../images/python-pyobject.svg";

## Table of Contents
1. [https://kirill-sklyarenko.ru/lenta/150-voprosov-na-sobesedovanie-python-bez-opyta](#1)
2. [https://kirill-sklyarenko.ru/lenta/150-voprosov-na-sobesedovanie-python-s-opytom-raboty](#2)
3. [https://proglib.io/p/python-interview/](#3)
4. [https://www.severcart.ru/blog/all/essential-python-interview-questions/](#4)
5. [https://pycoder.ru/python-interview-questions/](#5)
6. [ https://www.yandex.ru/turbo?text=https%3A%2F%2Fpythonist.ru%2F11-vazhnyh-voprosov-na-python-sobesedovaniyah%2F](#6)
7. [https://mcs.mail.ru/blog/spisok-voprosov-s-sobesedovaniy-python-dlya-data-sayentistov](#7)
8. [https://tproger.ru/translations/python-developer-interview-guide/
](#8)


## 1
 https://kirill-sklyarenko.ru/lenta/150-voprosov-na-sobesedovanie-python-bez-opyta

В50. Возьмем строку "I love Python". Напишите код, который выведет символы до буквы "t".

    >>> s = "I love Python"
    >>> i = 0
    >>> while s[i] != "t":
    print(s[i], end="")
    i += 1
    >>> I love Py

В51. Возьмем строку "I love Python". Напишите код, который выведет эту строку без пробелов.

    >>> s = "I love Python"
    >>> for i in s:
    if i == ' ': continue
    print(i, end='')
    >>> IlovePython

В52. Возьмем строку "I love Python". Напишите код, который выведет эту строку пять раз подряд.

    >>> s = "I love Python"
    >>> for i in range(6):
    print(s)
    >>> I love Python
    >>> I love Python
    >>> I love Python
    >>> I love Python
    >>> I love Python


В59. Сколько аргументов может принять range()?

От одного до трех:
    >>> list(range(5))
    [0, 1, 2, 3, 4]
    >>> list(range(-5))
    []
    >>> list(range(2, 7))
    [2, 3, 4, 5, 6]
    >>> list(range(-3, 4))
    [-3, -2, -1, 0, 1, 2, 3]
    >>> list(range(2, 9, 2))
    [2, 4, 6, 8]
    >>> list(range(9, 2, -1))
    [9, 8, 7, 6, 5, 4, 3]

В62. Как лучше всего поменять местами числовые значения объектов?

    >>> a, b = b, a

В63. Как можно выполнить несколько операций присвоения в одном предложении?

Первый способ (несколько объектов с уникальными значениями):
    >>> a, b, c = 3, 4, 5

Второй способ (несколько объектов с идентичными значениями):
    >>> a = b = c = 3

В66. Расскажите, какой в питоне механизм передачи параметров.

В питоне используется передача параметров по ссылке. Если изменить параметр внутри функции, то это отразится на выводе функции. Однако, если использовать в качестве параметров литералы (строки, числа, кортежа), то они передаются по значению (потому что они не изменяемые).

## 2
https://kirill-sklyarenko.ru/lenta/150-voprosov-na-sobesedovanie-python-s-opytom-raboty

В6. Приведите несколько методов, с помощью которых можно реализовать в питоне функционально ориентированное программирование.

Несколько методов могут помочь с итерацией по списку (list).

1. filter() может отфильтровать несколько значений на основе условия.

        >>> list(filter(lambda x:x>5,range(8)))
        [6, 7]

2. map() применяет функцию к каждому элементу итерируемого объекта.

        >>> list(map(lambda x:x**2,range(8)))
        [0, 1, 4, 9, 16, 25, 36, 49]

3. reduce() продолжает уменьшать последовательность (sequence) парами, пока не будет достигнуто единичное значение.

        >>> from functools import reduce
        >>> reduce(lambda x,y:x-y,[1,2,3,4,5])
        -13

В7. И все-таки, какая выдача у этого кода:

    x=[‘ab’,’cd’]
    print(len(list(map(list,x))))

Здесь на выходе ‘2’, потому что длина этого списка составляет два элемента. Выдача у list(map(list,x)) будет [[‘a’, ‘b’], [‘c’, ‘d’]], а в этом списке два элемента.

В22. Какой выход у этого кода?

    >>> b=(1)

На выходе не будет кортежа (tuple). Мы получим обычное целое число.

    >>> type(b)

Чтобы получить кортеж, мы можем добавить прямую декларацию с помощью запятой после числа 1:

    >>> b=(1,)
    >>> type(b)

В23. Почему игнорируются имена-идентификаторы, которые начинаются с символа подчеркивания?

В питоне не реализована концепция скрытой переменной (private variable), поэтому принято декларировать скрытые переменные первым символом в виде нижнего подчеркивания.


В24. Можно ли удалить пробелы из строки (string) “aaa bbb ccc ddd eee”?

Я вспомнил три способа.

Функция join():

    >>> s='aaa bbb ccc ddd eee'
    >>> s1=''.join(s.split())
    >>> s1
    ‘aaabbbcccdddeee’

Генератор списка (list comprehension):

    >>> s='aaa bbb ccc ddd eee'
    >>> s1=str(''.join(([i for i in s if i!=' '])))
    >>> s1
    ‘aaabbbcccdddeee’

Функция replace():

    >>> s='aaa bbb ccc ddd eee'
    >>> s1 = s.replace(' ','')
    >>> s1
    ‘aaabbbcccdddeee’

В28. Сейчас мы покажем код, в котором нужно удалить числа меньше 5 из списка (list) nums. Однако, ожидаемого эффекта он не дает. Можете показать нам, где баг?

    >>> nums=[1,2,5,10,3,100,9,24]
    >>> for i in nums:
         if i<5:
             nums.remove(i)
    >>> nums
    [2, 5, 10, 100, 9, 24]

В данном коде проверяется каждый элемент списка nums, т.е. окажется ли он меньше 5. Если условие выполняется, то данный элемент будет удален. На первой итерации, действительно, оказывается, что 1 меньше 5, поэтому данный элемент удаляется из списка. Однако данное действие вносит путаницу в индексы элементов, поэтому программа проверяет элемент 5, а не элемент 2. Решить данную проблему можно тремя способами:

Можно создать пустой массив и добавлять элементы с конца (append):

    >>> nums=[1,2,5,10,3,100,9,24]
    >>> newnums=[]
    >>> for i in nums:
         if i>=5:
    newnums.append(i)
    >>> newnums
    [5, 10, 100, 9, 24]

Можно воспользоваться генератором списка (list comprehension):

    >>> nums=[1,2,5,10,3,100,9,24]
    >>> newnums=[i for i in nums if i>=5]
    >>> newnums
    [5, 10, 100, 9, 24]

Можно воспользоваться функцией filter():

    >>> nums=[1,2,5,10,3,100,9,24]
    >>> newnums=list(filter(lambda x:x>=5, nums))
    >>> newnums
    [5, 10, 100, 9, 24]

В36. Можно ли сказать, что массив (array) NumPy лучше списка (list)?

Массивы NumPy имеют три преимущества перед списками:

    Они быстрее
    Они потребляют меньше памяти
    С ними удобнее работат

В41. Как можно провести отладку (debug) программы в Python? Дайте короткий ответ.

Для отладки в Python используется модуль pdb, отладчик (debugger) Python. Если запустить программу с pdb, то мы сможем пройти по коду пошагово.


В42. Можно ли осуществить динамическую загрузку модуля в Python?

При динамической загрузке модули загружаются только когда они становятся нужны. Такой подход — медленный, но он помогает эффективнее использовать память. В Python для этого можно использовать модуль importlib:

    import importlib
    module = importlib.import_module('my_package.my_module')

В43. Какие методы/функции мы используем для определения типа экземпляра (type of instance) и наследования (inheritance)?

Для этого используются type(), isinstance() и issubclass().

1. type() используется для определени типа объекта.

        >>> type(3)

        >>> type(False)

        >>> type(lambda :print("Hi"))

        >>> type(type)

2. isinstance() принимает два аргумента: значение (value) и тип (type). Если значение относится к соответствующему типу, то возвращается True. Если нет, то возвращается False.

        >>> isinstance(3,int)
        True
        >>> isinstance((1),tuple)
        False
        >>> isinstance((1,),tuple)
        True

3. issubclass() принимает два класса (classes) в качестве аргументов (arguments). Если второй наследует из первого, то возвращается True. Если нет, то возвращается False.

        >>> class A: pass
        >t; class B(A): pass
        >>> issubclass(B,A)
        True
        >>> issubclass(A,B)
        False

В47. Можете коротко объяснить, как используются модули sqlite3, ctypes, pickle, traceback и itertools.

- sqlite3 помогает обрабатывать базы данных, например SQLite
- ctypes позволяет создавать в питоне типы данных из Си и обрабатывать их
- pickle позволяет переносить любые структуры данных во внешние файлы
- traceback позволяет извлекать, форматировать и выводить на печать трассы вызовов (stack - traces)
- itertools помогает работать с перестановками (permutations), комбинациями    (combinations) и другими итерируемыми объектами (iterables).

В48. Расскажите про наследование (inheritance) в Python.

Когда один класс наследует из другого, его называют дочерним/производным/подклассом (child/derived/sub class), который наследует из родительского/базового/супер класса (parent/base/super class). Он наследует/получает все атрибуты и методы.

Наследование позволяет повторно использовать код и облегчает создание и дальнейшую работу приложений (applications). В Python поддерживаются следующие виды наследования:

- Единичное наследование (Single Inheritance) — класс наследует из одного базового класса.
- Множественное наследование (Multiple Inheritance) — класс наследует из двух или нескольких базовых классов.
- Многоуровневое наследование (Multilevel Inheritance) — класс наследует из базового класса, который, в свою очередь, наследует из другого базового класса.
- Иерархическое наследование (Hierarchical Inheritance) — два класса или несколько классов наследуют из одного базового класса (single base class).
- Гибридное наследование (Hybrid Inheritance) — сочетание двух или нескольких видов наследования.

В56. Что такое генератор (generator)?

В питоне генератор создает последовательность (sequence) значений, вдоль которой осуществляется итерация. То есть, это своего рода итерируемый объект (iterable). Мы пишем функцию, которая выдает (yield) значения по одному, а затем используем цикл for (for loop) для итерации вдоль нее.

    >>> def squares(n):
         i=1
         while(i<=n):
             yield i**2
         i+=1
    >>> for i in squares(7):
         print(i)
    1
    4
    9
    16
    25
    36
    49

В57. Ну тогда, что такое итератор (iterator)?

Итератор возвращает один объект за раз во время цикла итерации. Для создания итератора можно использовать функцию iter().

odds=iter([1,3,5,7,9])

Затем мы отправляем его в функцию next() каждый раз, когда хотим получить объект.

    >>> next(odds)
    1
    >>> next(odds)
    3
    >>> next(odds)
    5
    >>> next(odds)
    7
    >>> next(odds)
    9

Но при следующем вызове появится исключение остановки итерации (StopIteration exception), потому что закончили значения, по которым можно осуществлять итерацию.

    >>> next(odds)
    Traceback (most recent call last):
    File “<pyshell#295>”, line 1, in
    next(odds)
    StopIteration

В58. Хорошо, мы спросили вас про генераторы (generators) и итераторы (iterators), и вы дали верные ответы. Но ведь они звучат очень похоже?

Так и есть, но между ними существуют тонкие различия:

- Для генератора мы написали функцию, а для итератора можно использовать встроенные функции iter() и next().
- Для генератора используется ключевое слово yield для выдачи по одному объекту за раз.
- В генераторе может быть сколько угодно операторов yield.
- Генератор сохраняет текущее состояние локальных переменных (local variables) каждый - раз, когда yield приостанавливает цикл (loop). Итератор не использует локальные переменные, он работает только с итерируемым объектом (iterable).
- Итератор можно использовать с помощью класса, а генератор — нет.
- Генераторы работают быстро, компактно и проще.
- Итераторы экономнее потребляют память.



В60. Что такое временная подмена (Monkey Patching)?

Она модифицирует класс или модуль во время выполнения (at runtime), то есть представляет собой динамическую модификацию (dynamic modification). Пример:

    from pkg.module import MyClass

    def sayhello(self):
         print("Hello")

    MyClass.sayhello=sayhello

## 3
https://proglib.io/p/python-interview/

Изменяемые и неизменяемые типы данных

Все данные относятся к одному из двух типов – неизменяемые или изменяемые. Очевидно, что первые в конце программы выглядят точно так же, как и в начале. К ним относятся числа, строки и кортежи. С другой стороны, списки и словари могут измениться в процессе работы. Например, добавятся или удалятся элементы.

Когда данные передаются в функцию, способ их обработки зависит от типа. Например, для неизменяемых чисел создается независимая копия. Следовательно, любое преобразование внутри функции не повлияет на исходное число. И наоборот, вместо изменяемого списка передается указатель на то место в памяти, где он хранится. Таким образом, все трансформации повлияют на внешний объект.

    def foo(a=[]):
        a.append(1)
        print(a)

    foo()
    foo()
    foo()

Первый вызов функции foo предсказуемо выведет список, состоящий из одного элемента 1. Однако если вы ожидаете такого же результата от второго и третьего вызовов, то будете удивлены. На самом деле, вывод будет следующим:

    # [1]
    # [1, 1]
    # [1, 1, 1]

Так происходит, потому что при первом вызове в памяти создается пустой список a. Именно к нему функция будет обращаться и дальше, если не получит собственный аргумент. Так как список не копируется, а передается по ссылке, он будет изменяться.

Эту концепцию важно понять, чтобы не допускать подобных ошибок. Их сложно отследить в процессе отладки, поэтому приходится тратить много времени на поиск проблемы.


Лямбда-выражения

Лямбды пришли в Python из языка Lisp. Это простые анонимные функции, записанные в одну строку. Их можно объявить даже там, где нельзя воспользоваться инструкцией def. Например, эти выражения часто используются в методах filter и map.

    foo = [2, 18, 9, 22, 17, 24, 8, 12, 27]

    print(list(filter(lambda x: x % 3 == 0, foo)))
    # [18, 9, 24, 12, 27]

    print(list(map(lambda x: x * 2 + 10, foo)))
    # [14, 46, 28, 54, 44, 58, 26, 34, 64]

Списки

Многие программисты испытывают сложности с пониманием списков. Однако, это очень важная тема, и в ней необходимо разобраться.

Вот небольшая задачка по python-спискам для тренировки мозга:

    A0 = dict(zip(('a','b','c','d','e'),(1,2,3,4,5)))
    A1 = range(10)
    A2 = sorted([i for i in A1 if i in A0])
    A3 = sorted([A0[s] for s in A0])
    A4 = [i for i in A1 if i in A3]
    A5 = {i:i*i for i in A1}
    A6 = [[i,i*i] for i in A1]

Определите, что находится в каждой переменной, и сравните свои предположения с ответом.

    A0 = {'a': 1, 'c': 3, 'b': 2, 'e': 5, 'd': 4}
    A1 = range(0, 10)
    A2 = []
    A3 = [1, 2, 3, 4, 5]
    A4 = [1, 2, 3, 4, 5]
    A5 = {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}
    A6 = [[0, 0], [1, 1], [2, 4], [3, 9], [4, 16], [5, 25], [6, 36], [7, 49], [8, 64], [9, 81]]
Итераторы и генераторы

Итератор – это интерфейс, который позволяет перебирать элементы последовательности. Он используется, например, в цикле for ... in ..., но этот механизм скрыт от глаз разработчика. При желании итератор можно получить "в сыром виде", воспользовавшись функцией iter().

Чтобы получить следующий элемент коллекции или строки, нужно передать итератор функции next().

Под капотом функциональность реализуется в методах __iter__ и __next__.

Итераторы в Python

Пример простого итератора:

    class SimpleIterator:
        def __iter__(self):
            return self

        def __init__(self, limit):
            self.limit = limit
            self.counter = 0

        def __next__(self):
            if self.counter < self.limit:
                self.counter += 1
                return 1
            else:
                raise StopIteration

    simple_iter = SimpleIterator(5)

    for i in simple_iter:
        print(i)
    # 1
    # 1
    # 1
    # 1
    # 1

На базе итераторов в языке появились новые элементы синтаксического сахара: выражения-генераторы и генераторы коллекций. Они позволяют устанавливать условия для отбора.

    numbers = range(10)
    squared = [n ** 2 for n in numbers if n % 2 == 0]
    print(squared)   # [0, 4, 16, 36, 64]

В этом примере из списка чисел отбираются четные, а в финальную коллекцию вносятся их квадраты.

Выражения-генераторы не создают целый список заданной длины сразу, а добавляют элементы по мере необходимости.

Очевидно, что генераторы могут выполнять работу функций map и filter. Более того, они справляются с этой задачей эффективнее.

*args и **kwargs

Иногда нельзя предсказать, сколько аргументов получит функция. Чтобы обработать их, используются специальные конструкции *args и **kwargs.

На самом деле, названия переменных – args, kwargs – это просто соглашение. Важны здесь только звездочки. Они обозначают сборку аргументов в коллекцию (список или словарь). Одна звездочка предназначена для обычных аргументов, две – для именованных.

Можно заменить *args на *vars, а **kwargs на **options или другое слово. Программа будет работать так, как ожидается. Однако, другие разработчики могут вас не понять.

    def test_args(farg, *args):
        print("Первый известный аргумент: ", farg)
        for arg in args:
            print("Один из оставшихся аргументов: ", arg)

    test_args(1, "two", 3)
    # Первый известный аргумент: 1
    # Один из оставшихся аргументов: two
    # Один из оставшихся аргументов: 3

    def test_kwargs(farg, **kwargs):
        print("Первый известный аргумент: ", farg)
        for key in kwargs:
            print("Один из оставшихся аргументов: %s: %s" % (key, kwargs[key]))

    test_kwargs(farg=1, myarg2="two", myarg3=3)
    # formal arg: 1
    # Один из оставшихся аргументов: myarg2: two
    # Один из оставшихся аргументов: myarg3: 3

Конструкции *args и **kwargs можно использовать как самостоятельно, так и в комбинации с любым количеством обычных аргументов. Например, в коде выше первый параметр farg обрабатывается отдельно, а все остальные собираются в коллекцию.


Потоки

Вопрос о потоках – один из самых животрепещущих в сообществе. Поэтому вполне можно ожидать, что он прозвучит на собеседовании по Python.

Работа нескольких потоков иногда заканчивается конфликтом. Чтобы защититься от этого, CPython использует технологию Global Interpreter Lock.

Глобальный блокировщик следит за тем, чтобы активен был всегда только один поток. По сути, он просто запрещает параллельность. Хотя такой подход очень упрощает работу, он фактически убирает все преимущества многопоточной модели. Например, нельзя ускорить программу, разделив один поток на несколько. Python-сообщество неоднократно просило убрать GIL, однако, создатель языка решил оставить все как есть.

Многопоточность в Python

Впрочем, иногда потоки нужны. Например, на них можно переложить загрузку файлов с сервера. Для этого в Python используется модуль threading.

Код ниже демонстрирует добавление функции clock в поток.

    import threading
    import time
    def clock(interval):
        while True:
            print("The time is %s" % time.ctime())
            time.sleep(interval)
    t = threading.Thread(target=clock, args=(15,))
    t.daemon = True
    t.start()

Асинхронность

Асинхронность – еще один способ выполнения нескольких задач сразу. Она предлагает решать проблему с помощью функций обратного вызова (callback).

Встретив в коде блокирующий запрос, интерпретатор вешает на него сигнальный маячок и идет дальше. Когда запрос завершится, маячок подаст сигнал. В этот момент обработчик вернется, получит результат и вызовет коллбэк.

В Python есть несколько асинхронных библиотек. Самые популярные из них – стандартная AsyncIO и Tornado.

В последних версиях языка появились новые синтаксические конструкции async и await.

Тестирование

В Python есть стандартный модуль unittest. Он позволяет объединять тесты в группы, настраивать и автоматизировать их. Дополнение Mock дает возможность использовать mock-объекты, что облегчает тестирование.
Отладка

Python-код можно и нужно отлаживать. Для этого в языке есть специальный интерактивный дебаггер pdb.
Расширения на C/C++

Интерпретатор CPython позволяет внедрять в программы расширения, которые написаны на C и C++. Разработчик может оптимизировать код и пользоваться библиотеками языка C. Кроме того, можно управлять ресурсами на низком уровне.

## 4
https://www.severcart.ru/blog/all/essential-python-interview-questions/

Вопрос 6

Что распечатает код:

    def f(x,l=[]):
        for i in range(x):
            l.append(i*i)
        print(l)

    f(2)
    f(3,[3,2,1])
    f(3)

Ответ

    [0, 1]
    [3, 2, 1, 0, 1, 4]
    [0, 1, 0, 1, 4]

Почему?

Первый вызов функции волне очевиден, цикл добавляет 0, а затем 1 в пустой список. l – имя переменной которая указывает на список, хранящийся в памяти. Второй вызов начинается с создания нового списка, хранящегося в новом блоке памяти. l ссылается на новый список. Затем добавляются 0, 1 и 4 к новому списку. В третьем вызове функции происходит что-то странное. Она использует исходный список, хранящийся в исходной области памяти. Именно поэтому он начинается с 0 и 1.

Вопрос 10

Что распечатает следующий код:

```python
class A(object):
    def go(self):
        print("go A go!")
    def stop(self):
        print("stop A stop!")
    def pause(self):
        raise Exception("Not Implemented")

class B(A):
    def go(self):
        super(B, self).go()
        print("go B go!")

class C(A):
    def go(self):
        super(C, self).go()
        print("go C go!")
    def stop(self):
        super(C, self).stop()
        print("stop C stop!")

class D(B,C):
    def go(self):
        super(D, self).go()
        print("go D go!")
    def stop(self):
        super(D, self).stop()
        print("stop D stop!")
    def pause(self):
        print("wait D wait!")

class E(B,C): pass

a = A()
b = B()
c = C()
d = D()
e = E()

# specify output from here onwards

a.go()
b.go()
c.go()
d.go()
e.go()

a.stop()
b.stop()
c.stop()
d.stop()
e.stop()

a.pause()
b.pause()
c.pause()
d.pause()
e.pause()
```

Ответ

Вывод представлен далее

```python
a.go()
# go A go!

b.go()
# go A go!
# go B go!

c.go()
# go A go!
# go C go!

d.go()
# go A go!
# go C go!
# go B go!
# go D go!

e.go()
# go A go!
# go C go!
# go B go!

a.stop()
# stop A stop!

b.stop()
# stop A stop!

c.stop()
# stop A stop!
# stop C stop!

d.stop()
# stop A stop!
# stop C stop!
# stop D stop!

e.stop()
# stop A stop!

a.pause()
# ... Exception: Not Implemented

b.pause()
# ... Exception: Not Implemented

c.pause()
# ... Exception: Not Implemented

d.pause()
# wait D wait!

e.pause()
# ...Exception: Not Implemented
```
Вопрос 11

Какой выход будет от следующего кода?

```python
class Node(object):
    def __init__(self,sName):
        self._lChildren = []
        self.sName = sName
    def __repr__(self):
        return "<Node '{}'>".format(self.sName)
    def append(self,*args,**kwargs):
        self._lChildren.append(*args,**kwargs)
    # обходит дерево в глубину
    def print_all_1(self):
        print(self)
        for oChild in self._lChildren:
            oChild.print_all_1()
    # обходит дерево в ширину
    def print_all_2(self):
        def gen(o):
            lAll = [o,]
            while lAll:
                oNext = lAll.pop(0)
                lAll.extend(oNext._lChildren)
                yield oNext
        for oNode in gen(self):
            print(oNode)

oRoot = Node("root")
oChild1 = Node("child1")
oChild2 = Node("child2")
oChild3 = Node("child3")
oChild4 = Node("child4")
oChild5 = Node("child5")
oChild6 = Node("child6")
oChild7 = Node("child7")
oChild8 = Node("child8")
oChild9 = Node("child9")
oChild10 = Node("child10")

oRoot.append(oChild1)
oRoot.append(oChild2)
oRoot.append(oChild3)
oChild1.append(oChild4)
oChild1.append(oChild5)
oChild2.append(oChild6)
oChild4.append(oChild7)
oChild3.append(oChild8)
oChild3.append(oChild9)
oChild6.append(oChild10)

# specify output from here onwards

oRoot.print_all_1()
oRoot.print_all_2()

# распечатает:

oRoot.print_all_1()
<Node 'root'>
<Node 'child1'>
<Node 'child4'>
<Node 'child7'>
<Node 'child5'>
<Node 'child2'>
<Node 'child6'>
<Node 'child10'>
<Node 'child3'>
<Node 'child8'>
<Node 'child9'>

# распечатает:

oRoot.print_all_2()
<Node 'root'>
<Node 'child1'>
<Node 'child2'>
<Node 'child3'>
<Node 'child4'>
<Node 'child5'>
<Node 'child6'>
<Node 'child8'>
<Node 'child9'>
<Node 'child7'>
<Node 'child10'>
```

Почему это важно?

Потому что всё из чего состоят и строятся объекты, являются также объектами. Объекты состоят из сущностей, и их нужно как-то инициализировать. Они также связывают некоторые рекурсивные сущности и применяютя в генераторах.

Генераторы - это хорошо. Можно было достичь аналогичной функциональностьи в print_all_2, просто построив длинный список, а затем, печатав результат. Одно из хороших свойств генераторов является то, что они не занимают много места в памяти.

Стоит также отметить, что print_all_1 обходит дерево в глубину первым способом, в то время как print_all_2 преимущественно в ширину. Убедитесь, что вы понимаете, эти термины. Иногда один вид обхода является более предпочтительным, чем другой. Но это очень сильно зависит от приложения.

Вопрос 13

Отсортируйте следующие функции в порядке эффективности, первыми идут самые эффективные. Функции принимают список из дробных чисел между 0 и 1. Список должен быть довольно длинным, например, таким

[random.random() for i in range(100000)]

Как вы обоснуете правильность своего ответа?

```python
    def f1(lIn):
        l1 = sorted(lIn)
        l2 = [i for i in l1 if i<0.5]
        return [i*i for i in l2]

    def f2(lIn):
        l1 = [i for i in lIn if i<0.5]
        l2 = sorted(l1)
        return [i*i for i in l2]

    def f3(lIn):
        l1 = [i*i for i in lIn]
        l2 = sorted(l1)
        return [i for i in l1 if i<(0.5*0.5)]

Ответ:

Ряд эффективности функций: f2, f1, f3.
Чтобы это доказать, воспользуемся профилировщиками программного кода.
У Python есть встроенный пакет для профилирования
(https://docs.python.org/2/library/profile.html)


    import cProfile
    lIn = [random.random() for i in range(100000)]
    cProfile.run('f1(lIn)')
    cProfile.run('f2(lIn)')
    cProfile.run('f3(lIn)')


Развёрнутый вывод результатов работы профилировщика


    >>> cProfile.run('f1(lIn)')
         4 function calls in 0.045 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.009    0.009    0.044    0.044 <stdin>:1(f1)
        1    0.001    0.001    0.045    0.045 <string>:1(<module>)
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
        1    0.035    0.035    0.035    0.035 {sorted}


>>> cProfile.run('f2(lIn)')
         4 function calls in 0.024 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.008    0.008    0.023    0.023 <stdin>:1(f2)
        1    0.001    0.001    0.024    0.024 <string>:1(<module>)
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
        1    0.016    0.016    0.016    0.016 {sorted}


>>> cProfile.run('f3(lIn)')
         4 function calls in 0.055 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.016    0.016    0.054    0.054 <stdin>:1(f3)
        1    0.001    0.001    0.055    0.055 <string>:1(<module>)
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
        1    0.038    0.038    0.038    0.038 {sorted}
```

Выводы сделаны на основе времени работы каждой из функций.

Почему это важно?

Выявление и предупреждение ботлнеков, стоит потраченного времени. Чаще всего эффективное программирование сводится к здравому смыслу, в приведённом примере вторая функция явно быстрее, потому что сортирует список меньшего размера, в котором отфильтрованы все элементы меньшие 0.5. Менее очевидные вещи могут быть найдены с помощью специальных профилировщиков. Будет хорошо, если вы научитесь ими пользоваться.


## 5
https://pycoder.ru/python-interview-questions/

Какие типы данных в python?

    Изменяемые: list, dict, set
    Неизменяемые: number, boolean, string, tuple, frozenset

Объясните следующий код:

    1 b = [i for i in range(10)]
    2 b = (i for i in range(10))
    3 b = {i for i in range(10)}

    Создание списка от 0 до 9
    Создание генераторного выражения
    Создание сета от 0 до 9

map позволяет применить какую-либо функцию к любому iterable - объекту:

    1 alist = ['1', '2', '3']
    2 alist = map(int, alist)

В python 2 map вернет список, но в третьей версии вернется объект - итератор. Соответственно все числа преобразуются в int.

как из [[1, 2], [3, 4]] получить [1, 2, 3, 4]?

    1 alist = [[1, 2], [3, 4]]
    2 new_list = []
    3 for el in alist:
    4     for x in el:
    5         new_list.append(x)

Или, что аналогично, но гораздо лучше (питоничнее и быстрее):

    1 new_list = [x for el in alist for x in el]

Или, например, такой вариант (подсмотрел в книге Intermediate Python):

    1 import itertools
    2 alist = [[1, 2], [3, 4]]
    3 print(list(itertools.chain.from_iterable(alist)))

Напишите декоратор, который замеряет время работы функции.

     1 import time
     2
     3
     4 def timer(func):
     5     def wrapper():
     6         init_time = time.time()
     7         func()
     8         print(time.time() - init_time)
     9     return wrapper
    10
    11
    12 @timer
    13 def test():
    14     print('lol')
    15
    16
    17 test()

Генератор - это функция, которая возвращает итератор, каждый раз "запоминает" свое состояние и генерирует по одному элементу за раз. Создается генератор, используя ключевое слово yield. Пример простого генератора:

         1 def simple_generator():
         2     print("generate")
         3     yield 1
         4     yield 2
         5
         6
         7 >>> print(simple_generator())
         8 >>> <generator object simple_generator at 0x7f68b6937cd0>
         9 >>> print(dir(simple_generator()))
        10 >>> ['__class__', '__delattr__', '__doc__', '__format__', '__getattribute__',
        11  '__hash__', '__init__', '__iter__', '__name__', '__new__', '__reduce__',
        12  '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__',
        13  '__subclasshook__', 'close', 'gi_code', 'gi_frame', 'gi_running',
        14  'next', 'send', 'throw']
        15 >>> id(iter(simple_generator())) == id(simple_generator())
        16 >>> True

Как вы можете заметить, при вызове генератора он не был исполнен, потому что генераторы, в отличие от функций, не исполняются при вызове, а только при итерации по ним. Также видно, что генератор возвращает объект - генератор, который является итератором (есть next и __iter__). Кроме того, как вы можете заметить, генератор - это также self-iteraror.

        1 simple_gen = simple_generator()
        2 for x in simple_gen:
        3     print(x)
        4
        5 for x in simple_gen:
        6     print(x)

## 6

Вопрос № 1

Что будет в результате выполнения данного кода? Объясните ваш ответ.

    def extendList(val, list=[]):
        list.append(val)
        return list

    list1 = extendList(10)
    list2 = extendList(123, [])
    list3 = extendList('a')

    print (f"list1 = {list1}")
    print (f"list2 = {list2}")
    print (f"list3 = {list3}")

Как бы вы изменили функцию extendList, чтобы добиться более предсказуемого поведения?

Посмотреть ответ

Результат будет следующим:

    list1 = [10, 'a']
    list2 = [123]
    list3 = [10, 'a']

Многие могут ошибочно предположить, что list1 будет равен [10], а list3 будет равен ['a'], думая, что всякий раз при вызове функции extendList аргумент list будет равен значению по умолчанию [].

Однако, в действительности новый пустой список по умолчанию создается только один раз при определении функции. И затем этот список последовательно используется всякий раз, когда функция вызывается без второго аргумента. Это происходит потому, что значения по умолчанию вычисляются при определении функции, а не при ее вызове.

Таким образом, list1 и list3 имеют дело с одним и тем же списком по умолчанию, в то время как list2 использует пустой список, переданный ему во втором аргументе.

Чтобы каждый раз при вызове функции extendList без второго аргумента она бы использовала пустой список по умолчанию, определение этой функции можно было бы изменить следующим образом:

    def extendList(val, list=None):
        if list is None:
            list = []
        list.append(val)
        return list

В таком исполнении результат работы функции будет следующим:

    list1 = [10]
    list2 = [123]
    list3 = ['a']

Вопрос № 3

Что будет в результате выполнения данного кода? Объясните ваш ответ.

    class Parent(object):
        x = 1

    class Child1(Parent):
        pass

    class Child2(Parent):
        pass

    print(Parent.x, Child1.x, Child2.x)
    Child1.x = 2
    print(Parent.x, Child1.x, Child2.x)
    Parent.x = 3
    print(Parent.x, Child1.x, Child2.x)

Посмотреть ответ

Результатом выполнения данного кода будет:

    1 1 1
    1 2 1
    3 2 3

Многих удивляет, что последняя строка вывода — это 3 2 3, а не 3 2 1. Почему изменение значения Parent.x также меняет значение Child2.x, но в то же время не меняет значение Child1.x?

Ответ заключается в том, что в Python переменные класса обрабатываются компилятором как словари. Если имя переменной не найдено в словаре текущего класса, то поиск продолжается вверх по иерархии (то есть, по всем родительским классам) до тех пор, пока не будет найдено имя указанной переменной. Если имя указанной переменной нигде не будет найдено, то возникает ошибка AttributeError.

Следовательно, присвоение x = 1 в родительском классе делает переменную класса x (со значением 1) ссылочной в данном классе и во всех его дочерних классах также. Вот почему первый оператор print выдает 1 1 1.

Соответственно, если какой-либо из его дочерних классов переопределяет это значение (например, когда мы выполняем инструкцию Child1.x = 2), то значение изменяется только в этом дочернем классе. Вот почему второй оператор print выдает 1 2 1.

И наконец, если значение изменяется в родительском классе Parent (например, когда мы выполняем инструкцию Parent.x = 3), это изменение отражается также на всех его дочерних классах, которые еще не переопределили это значение (которое в этом случае будет Child2). Вот почему третий оператор вывода выводит 3 2 3.

Вопрос № 5

Что будет в результате выполнения данного кода?

    list = ['a', 'b', 'c', 'd', 'e']
    print list[10:]

Посмотреть ответ

Данный код выдаст в виде результата пустой список [], а ошибка IndexError не возникнет.

Как известно, попытка доступа к элементу списка с использованием индекса, превышающего число элементов (например, операция list[10] в списке выше), приводит к ошибке IndexError. Однако, попытка получить доступ к срезу списка с начальным индексом, превышающем количество элементов в списке, не приведет к IndexError и просто вернет пустой список.

Особенно неприятным это обстоятельство делает то, что оно может привести к ошибкам, которые действительно трудно отследить, поскольку во время выполнения кода не возникает никаких ошибок.

Вопрос № 7

Дан список из N чисел. Используя единичное представление списков, создайте новый список, элементы которого удовлетворяли бы следующим условиям:

    все числа должны быть четные;
    из первоначального списка должны быть взяты только элементы с четными индексами.

Например, если элемент list[2] является четным, то он должен быть включен в новый список, так как у него еще и четный индекс. Если же элемент list[3] также является четным, то он, несмотря на это, в результирующий список не попадает, так как его индекс является нечетным.

Посмотреть ответ

Простейшее решение данной задачи выглядит следующим образом:

    [x for x in list[::2] if x%2 == 0]

Например, пусть дан следующий список:

    list = [ 1 , 3 , 5 , 8 , 10 , 13 , 18 , 36 , 78 ]

Тогда наше преставление списков вычислит следующий список:

    [10, 18, 78]

Данное выражение сначала отбирает все элементы списка с четными индексами, а затем фильтрует на предмет четности.

Вопрос № 11

Дан список, состоящий из целых чисел. Напишите функцию, выводящую на экран наименьшее целое число, которое отсутствует в данном списке и не может быть получено суммированием его элементов (двух и более). Например, для списка a = [1,2,5,7] таким числом будет 4, а для списка a = [1,2,2,5,7] — 18.

Посмотреть ответ

```python
import  itertools
sum_list = []
stuff = [1,2, 5, 7]
for L in range(0, len(stuff)+1):
    for subset in itertools.combinations(stuff, L):
        sum_list.append(sum(subset))

new_list = list(set(sum_list))
new_list.sort()
for each in range(0,new_list[-1]+2):
    if each not in new_list:
        print(each)
        break
```
## 7
https://mcs.mail.ru/blog/spisok-voprosov-s-sobesedovaniy-python-dlya-data-sayentistov

1. В чем разница между списком и кортежем?

Мне задавали этот вопрос буквально на каждом собеседовании по Python/data science. Выучите ответ как свои пять пальцев:

- Список можно изменить после создания.
- Кортеж нельзя изменить после создания.
- Список упорядочен. Он представляет собой упорядоченные последовательности объектов, как - правило, одного и того же типа. Например, все имена пользователей упорядочены по дате создания: [«Seth», «Ema», «Eli»].
- У кортежа есть структура. В каждом индексе могут сосуществовать различные типы данных. - Например, такая запись базы данных в памяти: (2, «Ema», «2020–04–16») # id, name, created_at.


6. Определите класс car с двумя атрибутами: color и speed. Затем создайте экземпляр и верните speed

Вот как это сделать:

    class Car :
        def __init__(self, color, speed):
            self.color = color
            self.speed = speed
    car = Car('red','100mph')
    car.speed
    #=> '100mph'


7. В чем разница между методами экземпляра, класса и статическими методами в Python?

Методы экземпляра: принимают параметр self и относятся к определенному экземпляру класса.

Статические методы: используют декоратор @staticmethod, не связаны с конкретным экземпляром и являются автономными (атрибуты класса или экземпляра не изменяются).

Методы класса: принимают параметр cls, можно изменить сам класс.

Проиллюстрируем разницу на вымышленном классе CoffeeShop:

```python
    class CoffeeShop:
        specialty = 'espresso'

        def __init__(self, coffee_price):
            self.coffee_price = coffee_price

        # instance method
        def make_coffee(self):
            print(f'Making {self.specialty} for ${self.coffee_price}')

        # static method
        @staticmethod
        def check_weather():
            print('Its sunny')

        # class method
        @classmethod
        def change_specialty(cls, specialty):
            cls.specialty = specialty
            print(f'Specialty changed to {specialty}')
```

У класса CoffeeShop есть атрибут specialty (фирменный напиток), установленный по умолчанию в значение ‘espresso’. Каждый экземпляр CoffeeShop инициализируется с атрибутом coffee_price. У него также три метода: метод экземпляра, статический метод и метод класса.

Давайте инициализируем экземпляр с атрибутом coffee_price, равным 5. Затем вызовем метод экземпляра make_coffee:

```python
coffee_shop = CoffeeShop('5')
coffee_shop.make_coffee()
#=> Making espresso for $5
```

Теперь вызовем статический метод. Статические методы не могут изменять состояние класса или экземпляра, поэтому обычно используются для служебных функций, например, сложения двух чисел. Наши проверяют погоду. Говорят, что солнечно. Отлично!

```python
coffee_shop.check_weather()
#=> Its sunny
```

Теперь используем метод класса для изменения фирменного напитка (specialty), а затем сделаем кофе (make_coffee):

```python
coffee_shop.change_specialty('drip coffee')
#=> Specialty changed to drip coffee

coffee_shop.make_coffee()
#=> Making drip coffee for $5
```


Обратите внимание, что make_coffee раньше делал эспрессо, а теперь заваривает капельную кофеварку (drip coffee).

Статический метод и метода класса — сравнение

Метод класса Python может получить доступ к переменным класса, но статический метод не может получить доступ к переменным класса. Метод класса требует, чтобы первый формальный параметр был привязан к классу. Статический метод может присутствовать без каких-либо параметров. Мы используем @classmethod для создания методов класса. Мы используем @staticmethod для создания статических методов

10. Объясните, как работает функция reduce

Это может быть сложновато сразу понять, пока вы не используете ее несколько раз.

reduce принимает функцию и последовательность — и проходит по этой последовательности. На каждой итерации в функцию передаются как текущий элемент, так и выходные данные предыдущего элемента. В конце концов, возвращается одно значение:

    from functools import reduce
    def add_three(x,y):
        return x + y
    li = [1,2,3,5]
    reduce(add_three, li)
    #=> 11

16. Что означает self в классе?

Self ссылается на экземпляр класса. Так метод может обновлять объект, к которому принадлежит.

Ниже передача self в __init__() дает возможность установить цвет экземпляра при инициализации:

    class Shirt:
        def __init__(self, color):
            self.color = color

    s = Shirt('yellow')
    s.color
    #=> 'yellow'

19. В чем разница между списками и массивами?

Примечание: в стандартной библиотеке Python есть объект array, но здесь мы специально обсуждаем массив из популярной библиотеки Numpy.

Списки в каждом индексе можно заполнять разными типами данных. Массивы требуют однородных элементов.

Арифметические действия в списках добавляют или удаляют элементы из списка. Арифметические действия на массивах соответствуют функциям линейной алгебры.

Массивы используют меньше памяти и обладают значительно большей функциональностью

24. Как округлить число до трех десятичных знаков?

Используйте функцию round(value, decimal_places):

    a = 5.12345
    round(a,3)
    #=> 5.123


25. Как разбить список?

Синтаксис функции включает три аргумента: list[start:stop:step], где step — это интервал, через который возвращаются элементы:

    a = [0,1,2,3,4,5,6,7,8,9]

    print(a[:2])
    #=> [0, 1]

    print(a[8:])
    #=> [8, 9]

    print(a[2:8])
    #=> [2, 3, 4, 5, 6, 7]

    print(a[2:8:2])
    #=> [2, 4, 6]


30. Где быстрее поиск: в словарях или списках?

Поиск значения в списке занимает O(n) времени, потому что нужно пройти весь список.

Поиск ключа в словаре занимает O(1) времени, потому что это хэш-таблица.

Разница во времени может быть огромной, если значений много, поэтому для производительности обычно рекомендуют словари. Но у них есть другие ограничения, такие как необходимость уникальных ключей.


31. В чем разница между модулем и пакетом?

Модуль — это файл или набор файлов, которые импортируются вместе:

    import sklearn

Пакет — это каталог с модулями:

    from sklearn import cross_validation

Таким образом, пакеты — это модули, но не все модули являются пакетами.


34. Как удалить из списка дубликаты?

Это можно сделать путем преобразования списка в набор, а затем обратно в список:

    a = [1,1,1,2,3]
    a = list(set(a))
    print(a)
    #=> [1, 2, 3]


38. Как объединить два списка в список кортежей?

Для объединения в список кортежей можно использовать функцию zip, причем не только двух, но трех и более списков.

    a = ['a','b','c']
    b = [1,2,3]

    [(k,v) for k,v in zip(a,b)]
    #=> [('a', 1), ('b', 2), ('c', 3)]


42. Почему мы используем enumerate() при итерации последовательности?

enumerate() позволяет отслеживать индекс при итерации последовательности. Это более нативный способ, чем определение и приращение целого числа, представляющего индекс:

    li = ['a','b','c','d','e']

    for idx,val in enumerate(li):
    print(idx, val)
    #=> 0 a
    #=> 1 b
    #=> 2 c
    #=> 3 d
    #=> 4 e


44. Преобразуйте следующий цикл for в генератор списков (list comprehension)

Дан следующий цикл for:

    a = [1,2,3,4,5]

    a2 = []
    for i in a:
         a2.append(i + 1)
    print(a2)
    #=> [2, 3, 4, 5, 6]

    Результат:

    a3 = [i+1 for i in a]

    print(a3)
    #=> [2, 3, 4, 5, 6]

Генератор списка обычно считается более каноническим способом в Python, если он остается понятным.
45. Приведите пример тернарного оператора

Тернарный (условный) оператор — это однострочный оператор if/else.

Синтаксис такой: a if condition else b.

    x = 5
    y = 10

    'greater' if x > 6 else 'less'
    #=> 'less'

    'greater' if y > 6 else 'less'
    #=> 'greater'

46. Проверьте, что в строке только числа

Можно использовать isnumeric():

    '123a'.isnumeric()
    #=> False

    '123'.isnumeric()
    #=> True

47. Проверьте, что в строке только буквы

Можно использовать isalpha():

    '123a'.isalpha()
    #=> False

    'a'.isalpha()
    #=> True

48. Проверьте, что в строке только буквы и цифры

Здесь можно использовать isalnum():

    '123abc...'.isalnum()
    #=> False

    '123abc'.isalnum()
    #=> True


51. В чем разница между remove, del и pop?

remove() удаляет первое совпадающее значение:

    li = ['a','b','c','d']

    li.remove('b')
    li
    #=> ['a', 'c', 'd']

del удаляет элемент по его индексу:

    li = ['a','b','c','d']

    del li[0]
    li
    #=> ['b', 'c', 'd']

pop() удаляет элемент по индексу и возвращает этот элемент:

    li = ['a','b','c','d']

    li.pop(2)
    #=> 'c'

    li
    #=> ['a', 'b', 'd']


52. Приведите пример генератора словарей (dict comprehension)

Ниже мы создадим словарь с буквами алфавита в качестве ключей и индексами в качестве значений:

    # создаем список букв
    import string
    list(string.ascii_lowercase)
    alphabet = list(string.ascii_lowercase)

    # генерация словаря
    d = {val:idx for idx,val in enumerate(alphabet)}

    d
    #=> {'a': 0,
    #=> 'b': 1,
    #=> 'c': 2,
    #=> ...
    #=> 'x': 23,
    #=> 'y': 24,
    #=> 'z': 25}

## 8
https://tproger.ru/translations/python-developer-interview-guide/

Создайте логируемый декоратор

Возможно, вам потребуется логировать то, что выполняет определённая функция. Как правило, логирование прописывается внутри функции (класса). Однако, иногда нужно отследить поведение самой функции внутри программы.

Посмотрите на небольшой декоратор, который можно использовать для записи названия любой функции и того, что она делает:



```python
import logging

def log(func):
    """
    Логируем какая функция вызывается
    """

    def wrap_log(*args, **kwargs):
        name = func.__name__
        logger = logging.getLogger(name)
        logger.setLevel(logging.INFO)

        # Открываем файл логов для записи
        fh = logging.FileHandler("%s.log" % name)
        fmt = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        formatter = logging.Formatter(fmt)
        fh.setFormatter(formatter)
        logger.addHandler(fh)

        logger.info("Вызов функции: %s" % name)
        result = func(*args, **kwargs)
        logger.info("Результат: %s" % result)
        return func

    return wrap_log


@log
def double_function(a):
    """
    Умножаем полученный параметр
    """
    return a*2


if __name__ == "__main__":
    value = double_function(2)
```

Этот небольшой скрипт содержит функцию log, которая принимает функцию как единственный аргумент. Мы создаем объект логгер, а название лог-файла такое же, как и у функции. После этого функция log будет записывать, как наша функция была вызвана и что она возвращает, если возвращает.

Передача аргументов
Как передаются неизменяемые объекты?

Неизменяемые объекты передаются «по значению». Такие объекты, как целые числа и строки, передаются в виде ссылок на объекты, а не в виде копий объектов.
Как передаются изменяемые объекты?

Изменяемые объекты передаются «по указателю». Такие объекты, как списки и словари, также передаются в виде ссылок на объекты, что очень похоже на то, как в языке C передаются указатели на массивы – изменяемые объекты допускают возможность непосредственного изменения внутри функции так же, как и массивы в языке C.

Пример:

    >>> def f(a):   # Имени a присваивается переданный объект
    ...     a = 99  # Изменяется только локальная переменная
    ...
    >>> b = 88
    >>> f(b)# Первоначально имена a и b ссылаются на одно и то же число 88
    >>> print(b)    # Переменная b не изменилась
    88

В этом фрагменте в момент вызова функции f(b) переменной a присваивается объект 88, но переменная a существует только внутри вызванной функции. Изменение переменной a внутри функции не оказывает влияния на окружение, откуда была вызвана функция, – просто в момент вызова создается совершенно новый объект a.


## Sources
- [Reference Counting in Python](http://edcjones.tripod.com/refcount.html)
- [Python pointers: what's the point?](https://habr.com/ru/company/mailru/blog/454324/)
